(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tsparticles-engine", "./Utils"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ImageDrawer = void 0;
    const tsparticles_engine_1 = require("tsparticles-engine");
    const Utils_1 = require("./Utils");
    class ImageDrawer {
        constructor(engine) {
            this.loadImageShape = async (imageShape) => {
                if (!this._engine.loadImage) {
                    throw new Error(`${tsparticles_engine_1.errorPrefix} image shape not initialized`);
                }
                await this._engine.loadImage({
                    name: imageShape.name,
                    replaceColor: imageShape.replaceColor ?? imageShape.replace_color ?? false,
                    src: imageShape.src,
                });
            };
            this._engine = engine;
        }
        addImage(image) {
            if (!this._engine.images) {
                this._engine.images = [];
            }
            this._engine.images.push(image);
        }
        draw(context, particle, radius, opacity) {
            const image = particle.image, element = image?.element;
            if (!element) {
                return;
            }
            const ratio = image?.ratio ?? 1, pos = {
                x: -radius,
                y: -radius,
            };
            context.globalAlpha = opacity;
            context.drawImage(element, pos.x, pos.y, radius * 2, (radius * 2) / ratio);
            context.globalAlpha = 1;
        }
        getSidesCount() {
            return 12;
        }
        async init(container) {
            const options = container.actualOptions;
            if (!options.preload || !this._engine.loadImage) {
                return;
            }
            for (const imageData of options.preload) {
                this._engine.loadImage(imageData);
            }
        }
        loadShape(particle) {
            if (particle.shape !== "image" && particle.shape !== "images") {
                return;
            }
            if (!this._engine.images) {
                this._engine.images = [];
            }
            const imageData = particle.shapeData, image = this._engine.images.find((t) => t.name === imageData.name || t.source === imageData.src);
            if (!image) {
                this.loadImageShape(imageData).then(() => {
                    this.loadShape(particle);
                });
            }
        }
        particleInit(container, particle) {
            if (particle.shape !== "image" && particle.shape !== "images") {
                return;
            }
            if (!this._engine.images) {
                this._engine.images = [];
            }
            const images = this._engine.images, imageData = particle.shapeData, color = particle.getFillColor(), image = images.find((t) => t.name === imageData.name || t.source === imageData.src);
            if (!image) {
                return;
            }
            const replaceColor = imageData.replaceColor ?? imageData.replace_color ?? image.replaceColor;
            if (image.loading) {
                setTimeout(() => {
                    this.particleInit(container, particle);
                });
                return;
            }
            (async () => {
                let imageRes;
                if (image.svgData && color) {
                    imageRes = await (0, Utils_1.replaceImageColor)(image, imageData, color, particle);
                }
                else {
                    imageRes = {
                        color,
                        data: image,
                        element: image.element,
                        loaded: true,
                        ratio: imageData.width && imageData.height ? imageData.width / imageData.height : image.ratio ?? 1,
                        replaceColor: replaceColor,
                        source: imageData.src,
                    };
                }
                if (!imageRes.ratio) {
                    imageRes.ratio = 1;
                }
                const fill = imageData.fill ?? particle.fill, close = imageData.close ?? particle.close, imageShape = {
                    image: imageRes,
                    fill,
                    close,
                };
                particle.image = imageShape.image;
                particle.fill = imageShape.fill;
                particle.close = imageShape.close;
            })();
        }
    }
    exports.ImageDrawer = ImageDrawer;
});
